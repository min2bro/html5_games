<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fraction Match Tiles</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&family=Roboto:wght@300;400;700&display=swap">
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
background: linear-gradient(135deg, #1a2980 0%, #26d0ce 100%);
color: #fff;
font-family: 'Roboto', sans-serif;
min-height: 100vh;
display: flex;
justify-content: center;
align-items: center;
padding: 20px;
}

.game-container {
width: 100%;
max-width: 850px;
background: rgba(255, 255, 255, 0.1);
backdrop-filter: blur(10px);
border-radius: 16px;
box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
overflow: hidden;
position: relative;
border: 1px solid rgba(255, 255, 255, 0.2);
}

.header {
text-align: center;
padding: 25px 20px;
background: rgba(25, 42, 86, 0.7);
position: relative;
overflow: hidden;
}

.header::before {
content: "";
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(45deg, rgba(255,255,255,0.05) 25%, transparent 25%, transparent 50%,
rgba(255,255,255,0.05) 50%, rgba(255,255,255,0.05) 75%, transparent 75%, transparent);
background-size: 40px 40px;
}

h1 {
font-family: 'Lora', serif;
font-size: 2.8rem;
margin-bottom: 8px;
font-weight: 700;
letter-spacing: 0.5px;
position: relative;
text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.subtitle {
font-size: 1.2rem;
opacity: 0.9;
max-width: 500px;
margin: 0 auto;
line-height: 1.5;
color: #a0d2ff;
}

.stats {
display: flex;
justify-content: space-between;
padding: 20px;
background: rgba(15, 32, 76, 0.6);
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
font-size: 1.1rem;
flex-wrap: wrap;
}

.stat-box {
text-align: center;
padding: 12px 18px;
background: rgba(255, 255, 255, 0.15);
border-radius: 12px;
min-width: 100px;
margin: 5px;
box-shadow: 0 4px 6px rgba(0,0,0,0.1);
backdrop-filter: blur(5px);
}

.stat-label {
font-size: 0.95rem;
opacity: 0.8;
margin-bottom: 5px;
}

.stat-value {
font-size: 2rem;
font-weight: 700;
color: #fff;
text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.game-area {
padding: 25px;
text-align: center;
position: relative;
}

.grid-container {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 15px;
max-width: 600px;
margin: 0 auto;
}

.tile {
aspect-ratio: 1;
background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%);
border-radius: 10px;
display: flex;
justify-content: center;
align-items: center;
font-size: 2.2rem;
font-weight: 700;
color: white;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 6px 12px rgba(0,0,0,0.2);
position: relative;
overflow: hidden;
border: 2px solid rgba(255, 255, 255, 0.3);
}

.tile::before {
content: "";
position: absolute;
top: -50%;
left: -50%;
width: 200%;
height: 200%;
background: rgba(255, 255, 255, 0.1);
transform: rotate(30deg);
}

.tile.selected {
transform: scale(0.95);
box-shadow: 0 0 0 4px #f1c40f, 0 0 20px rgba(241, 196, 15, 0.8);
z-index: 10;
}

.tile.matched {
transform: scale(0.01);
opacity: 0;
pointer-events: none;
}

.fraction {
font-family: 'Lora', serif;
text-align: center;
line-height: 1.1;
position: relative;
z-index: 2;
}

.fraction span {
display: block;
}

.fraction .numerator {
border-bottom: 3px solid rgba(255, 255, 255, 0.5);
padding-bottom: 8px;
margin-bottom: 8px;
}

.controls {
display: flex;
justify-content: center;
gap: 15px;
margin-top: 30px;
flex-wrap: wrap;
}

.btn {
padding: 16px 32px;
font-size: 1.1rem;
background: linear-gradient(to right, #3498db, #2c3e50);
color: white;
border: none;
border-radius: 50px;
cursor: pointer;
transition: all 0.3s;
font-weight: 500;
letter-spacing: 0.5px;
box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.btn:hover {
transform: translateY(-3px);
box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

.btn:active {
transform: translateY(1px);
}

.game-over {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(15, 32, 76, 0.95);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 100;
opacity: 0;
pointer-events: none;
transition: all 0.5s ease;
padding: 20px;
}

.game-over.active {
opacity: 1;
pointer-events: all;
}

.game-over h2 {
font-family: 'Lora', serif;
font-size: 3.5rem;
margin-bottom: 20px;
color: #fff;
text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.game-over p {
font-size: 1.5rem;
margin-bottom: 30px;
text-align: center;
max-width: 500px;
line-height: 1.6;
color: #a0d2ff;
}

.final-stats {
display: flex;
gap: 30px;
margin-bottom: 30px;
flex-wrap: wrap;
justify-content: center;
}

.final-stat {
text-align: center;
min-width: 150px;
background: rgba(255, 255, 255, 0.15);
padding: 20px;
border-radius: 12px;
box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.final-stat .label {
font-size: 1.2rem;
margin-bottom: 10px;
opacity: 0.8;
}

.final-stat .value {
font-size: 2.8rem;
font-weight: 700;
color: #fff;
}

.timer-container {
position: relative;
height: 10px;
background: rgba(255, 255, 255, 0.1);
border-radius: 5px;
overflow: hidden;
margin: 20px auto;
max-width: 600px;
}

.timer-bar {
position: absolute;
top: 0;
left: 0;
height: 100%;
width: 100%;
background: linear-gradient(to right, #2ecc71, #f1c40f, #e74c3c);
transition: width 0.5s linear;
}

.timer-text {
position: absolute;
top: -30px;
left: 0;
width: 100%;
text-align: center;
font-size: 1.3rem;
font-weight: bold;
color: #fff;
text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.combo-display {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
font-size: 5rem;
font-weight: bold;
color: #f1c40f;
opacity: 0;
pointer-events: none;
z-index: 200;
text-shadow: 0 0 15px rgba(0,0,0,0.5);
animation: comboPulse 1s ease-out;
}

@keyframes comboPulse {
0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
}

.powerups {
display: flex;
justify-content: center;
gap: 20px;
margin-top: 25px;
flex-wrap: wrap;
}

.powerup {
display: flex;
flex-direction: column;
align-items: center;
background: rgba(255, 255, 255, 0.15);
padding: 15px;
border-radius: 12px;
box-shadow: 0 4px 10px rgba(0,0,0,0.2);
min-width: 140px;
transition: all 0.3s;
backdrop-filter: blur(5px);
border: 1px solid rgba(255, 255, 255, 0.2);
}

.powerup:hover {
transform: translateY(-5px);
box-shadow: 0 8px 15px rgba(0,0,0,0.3);
}

.powerup-icon {
font-size: 2.2rem;
margin-bottom: 12px;
width: 60px;
height: 60px;
display: flex;
align-items: center;
justify-content: center;
border-radius: 50%;
color: white;
background: rgba(0,0,0,0.2);
}

.reveal-icon {
background: rgba(52, 152, 219, 0.7);
}

.shuffle-icon {
background: rgba(231, 76, 60, 0.7);
}

.powerup-text {
font-size: 1rem;
text-align: center;
margin-bottom: 8px;
font-weight: 500;
}

.powerup-count {
font-weight: bold;
font-size: 1.5rem;
color: #fff;
}

/* Animations */
@keyframes pulse {
0% { transform: scale(1); }
50% { transform: scale(1.05); }
100% { transform: scale(1); }
}

.pulse {
animation: pulse 0.5s ease;
}

/* Mobile optimizations */
@media (max-width: 768px) {
.grid-container {
grid-template-columns: repeat(3, 1fr);
gap: 12px;
}

.tile {
font-size: 1.8rem;
}

h1 {
font-size: 2.2rem;
}

.subtitle {
font-size: 1rem;
}

.stats {
justify-content: center;
gap: 10px;
}

.controls {
flex-direction: column;
align-items: center;
}

.btn {
width: 100%;
max-width: 300px;
}

.powerups {
flex-direction: column;
align-items: center;
}

.powerup {
width: 100%;
max-width: 250px;
}
}

@media (max-width: 480px) {
.grid-container {
gap: 10px;
}

.tile {
font-size: 1.5rem;
}

.header {
padding: 20px 15px;
}

h1 {
font-size: 1.9rem;
}

.stat-box {
min-width: 80px;
padding: 10px 15px;
font-size: 0.9rem;
}

.stat-value {
font-size: 1.8rem;
}

.game-area {
padding: 20px 15px;
}
}
</style>
</head>
<body>
<div class="game-container">
<div class="header">
<h1>Fraction Match Tiles</h1>
<div class="subtitle">Select two equivalent fractions before time runs out!</div>
</div>

<div class="stats">
<div class="stat-box">
<div class="stat-label">Level</div>
<div class="stat-value" id="level">1</div>
</div>
<div class="stat-box">
<div class="stat-label">Moves</div>
<div class="stat-value" id="moves">0</div>
</div>
<div class="stat-box">
<div class="stat-label">Score</div>
<div class="stat-value" id="score">0</div>
</div>
<div class="stat-box">
<div class="stat-label">Combo</div>
<div class="stat-value" id="combo">1x</div>
</div>
</div>

<div class="game-area">
<div class="timer-container">
<div class="timer-bar" id="timer-bar"></div>
<div class="timer-text" id="timer-text">40s</div>
</div>

<div class="grid-container" id="grid"></div>

<div class="powerups">
<div class="powerup" id="reveal-powerup">
<div class="powerup-icon reveal-icon">üîç</div>
<div class="powerup-text">Reveal a Match</div>
<div class="powerup-count" id="reveal-count">3</div>
</div>
<div class="powerup" id="shuffle-powerup">
<div class="powerup-icon shuffle-icon">üîÄ</div>
<div class="powerup-text">Shuffle Tiles</div>
<div class="powerup-count" id="shuffle-count">3</div>
</div>
</div>

<div class="controls">
<button class="btn" id="restart">New Game</button>
</div>
</div>

<div class="game-over" id="game-over">
<h2 id="game-over-title">Game Over!</h2>
<p id="game-over-message">Time's up! Better luck next time.</p>

<div class="final-stats">
<div class="final-stat">
<div class="label">Level Reached</div>
<div class="value" id="final-level">1</div>
</div>
<div class="final-stat">
<div class="label">Final Score</div>
<div class="value" id="final-score">0</div>
</div>
<div class="final-stat">
<div class="label">Matches Made</div>
<div class="value" id="final-matches">0</div>
</div>
</div>

<button class="btn" id="play-again">Play Again</button>
</div>

<div class="combo-display" id="combo-display"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
// Game elements
const grid = document.getElementById('grid');
const movesDisplay = document.getElementById('moves');
const scoreDisplay = document.getElementById('score');
const comboDisplay = document.getElementById('combo');
const levelDisplay = document.getElementById('level');
const restartBtn = document.getElementById('restart');
const gameOverScreen = document.getElementById('game-over');
const finalScoreDisplay = document.getElementById('final-score');
const finalLevelDisplay = document.getElementById('final-level');
const finalMatchesDisplay = document.getElementById('final-matches');
const playAgainBtn = document.getElementById('play-again');
const revealPowerup = document.getElementById('reveal-powerup');
const revealCount = document.getElementById('reveal-count');
const shufflePowerup = document.getElementById('shuffle-powerup');
const shuffleCount = document.getElementById('shuffle-count');
const comboPopup = document.getElementById('combo-display');
const gameOverTitle = document.getElementById('game-over-title');
const gameOverMessage = document.getElementById('game-over-message');
const timerBar = document.getElementById('timer-bar');
const timerText = document.getElementById('timer-text');

// Game state
let moves = 0;
let score = 0;
let timeLeft = 40;
let level = 1;
let timer;
let firstTile = null;
let secondTile = null;
let canClick = true;
let tiles = [];
let matches = 0;
let combo = 1;
let revealPowerupCount = 3;
let shufflePowerupCount = 3;

// Fraction pairs by difficulty
const difficultyFractions = {
1: [
[1, 2, 2, 4],
[1, 3, 2, 6],
[1, 4, 2, 8],
[2, 3, 4, 6],
[3, 4, 6, 8]
],
2: [
[1, 5, 2, 10],
[2, 5, 4, 10],
[3, 5, 6, 10],
[1, 6, 2, 12],
[5, 6, 10, 12],
[3, 8, 6, 16]
],
3: [
[4, 7, 8, 14],
[5, 8, 10, 16],
[3, 7, 6, 14],
[5, 7, 10, 14],
[7, 9, 14, 18],
[5, 9, 10, 18],
[11, 15, 22, 30]
]
};

// Initialize the game
function initGame() {
// Reset game state
moves = 0;
score = 0;
level = 1;
matches = 0;
combo = 1;
revealPowerupCount = 3;
shufflePowerupCount = 3;
canClick = true;
timeLeft = 40;

// Hide game over screen
gameOverScreen.classList.remove('active');

// Update displays
movesDisplay.textContent = moves;
scoreDisplay.textContent = score;
comboDisplay.textContent = combo + "x";
levelDisplay.textContent = level;
revealCount.textContent = revealPowerupCount;
shuffleCount.textContent = shufflePowerupCount;

// Clear grid
grid.innerHTML = '';
tiles = [];

// Generate tiles
generateTiles();

// Start timer
startTimer();
}

// Generate tiles based on current level
function generateTiles() {
const tileValues = [];
const pairsCount = level + 3; // 4 pairs for level 1, 5 for level 2, etc.
const fractionPool = [...difficultyFractions[level]];

// Create pairs
for (let i = 0; i < pairsCount; i++) {
const randomIndex = Math.floor(Math.random() * fractionPool.length);
const pair = fractionPool[randomIndex];
fractionPool.splice(randomIndex, 1);

// Add both fractions to the tile values
tileValues.push({
numerator: pair[0],
denominator: pair[1],
value: pair[0] / pair[1],
difficulty: level
});

tileValues.push({
numerator: pair[2],
denominator: pair[3],
value: pair[2] / pair[3],
difficulty: level
});
}

// Shuffle tiles
shuffleArray(tileValues);

// Create tiles
tileValues.forEach((value, index) => {
const tile = document.createElement('div');
tile.classList.add('tile');
tile.dataset.index = index;
tile.dataset.value = value.value;
tile.dataset.numerator = value.numerator;
tile.dataset.denominator = value.denominator;
tile.dataset.difficulty = value.difficulty;

// Create tile content
tile.innerHTML = `
<div class="fraction">
<span class="numerator">${value.numerator}</span>
<span class="denominator">${value.denominator}</span>
</div>
`;

tile.addEventListener('click', () => selectTile(tile));
grid.appendChild(tile);
tiles.push(tile);
});
}

// Select tile function
function selectTile(tile) {
if (!canClick || tile.classList.contains('matched') || tile.classList.contains('selected'))
return;

if (!firstTile) {
// First tile selected
firstTile = tile;
tile.classList.add('selected');
} else {
// Second tile selected
secondTile = tile;
tile.classList.add('selected');
canClick = false;

moves++;
movesDisplay.textContent = moves;

// Check for match after a short delay
setTimeout(checkForMatch, 500);
}
}

// Check if tiles match
function checkForMatch() {
const isMatch = firstTile.dataset.value === secondTile.dataset.value;

if (isMatch) {
// Calculate points based on difficulty
const difficulty = parseInt(firstTile.dataset.difficulty);
const basePoints = difficulty * 50;
const points = basePoints * combo;

// Update score
score += points;
scoreDisplay.textContent = score;

// Update matches
matches++;

// Increase combo
combo++;
comboDisplay.textContent = combo + "x";

// Show combo popup if combo > 1
if (combo > 2) {
comboPopup.textContent = combo + "x COMBO!";
comboPopup.style.opacity = "1";

setTimeout(() => {
comboPopup.style.opacity = "0";
}, 1000);
}

// Mark as matched
firstTile.classList.add('matched');
secondTile.classList.add('matched');

// Reset selection
resetSelection();

// Check if level is complete
if (matches === level + 3) {
levelUp();
}
} else {
// Reset combo on mismatch
combo = 1;
comboDisplay.textContent = combo + "x";

// Remove selection
firstTile.classList.remove('selected');
secondTile.classList.remove('selected');

// Reset selection
resetSelection();
}
}

// Reset selection
function resetSelection() {
firstTile = null;
secondTile = null;
canClick = true;
}

// Start game timer
function startTimer() {
timeLeft = 45 - (level * 5); // 40s for Easy, 35s for Medium, 30s for Hard
updateTimerDisplay();

clearInterval(timer);
timer = setInterval(() => {
timeLeft--;
updateTimerDisplay();

if (timeLeft <= 0) {
endGame(false);
}
}, 1000);
}

// Update timer display
function updateTimerDisplay() {
timerText.textContent = timeLeft + "s";
const percentage = (timeLeft / (45 - (level * 5))) * 100;
timerBar.style.width = percentage + "%";

// Change color based on time left
if (timeLeft < 15) {
timerBar.style.background = "#e74c3c";
} else if (timeLeft < 30) {
timerBar.style.background = "#f1c40f";
}
}

// Level up function
function levelUp() {
level++;
matches = 0;

// Update level display
levelDisplay.textContent = level;

// Add time for completing level
timeLeft += 15;

// Generate new tiles
setTimeout(() => {
// Clear grid
grid.innerHTML = '';
tiles = [];

// Generate new tiles for next level
generateTiles();

// Reset combo
combo = 1;
comboDisplay.textContent = combo + "x";

// Restart timer
startTimer();
}, 1000);
}

// End game function
function endGame(isWin) {
clearInterval(timer);
canClick = false;

// Update final stats
finalScoreDisplay.textContent = score;
finalLevelDisplay.textContent = level;
finalMatchesDisplay.textContent = matches;

// Set game over message
if (isWin) {
gameOverTitle.textContent = "Congratulations!";
gameOverMessage.textContent = `You completed all levels with a score of ${score}!`;
} else {
gameOverTitle.textContent = "Game Over!";
gameOverMessage.textContent = `Time's up! You reached level ${level} with ${score} points.`;
}

// Show game over screen
setTimeout(() => {
gameOverScreen.classList.add('active');
}, 500);
}

// Shuffle array function
function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[array[i], array[j]] = [array[j], array[i]];
}
return array;
}

// Reveal a matching pair
function revealMatch() {
if (revealPowerupCount <= 0) return;

revealPowerupCount--;
revealCount.textContent = revealPowerupCount;

// Find two matching tiles that haven't been matched yet
const unmatchedTiles = tiles.filter(tile =>
!tile.classList.contains('matched') &&
!tile.classList.contains('selected')
);

if (unmatchedTiles.length < 2) return;

// Find a pair
let firstHint = null;
let secondHint = null;

for (let i = 0; i < unmatchedTiles.length; i++) {
for (let j = i + 1; j < unmatchedTiles.length; j++) {
if (unmatchedTiles[i].dataset.value === unmatchedTiles[j].dataset.value) {
firstHint = unmatchedTiles[i];
secondHint = unmatchedTiles[j];
break;
}
}
if (firstHint) break;
}

if (!firstHint) return;

// Temporarily highlight the tiles
firstHint.classList.add('selected');
secondHint.classList.add('selected');

setTimeout(() => {
firstHint.classList.remove('selected');
secondHint.classList.remove('selected');
}, 2000);
}

// Shuffle unmatched tiles
function shuffleTiles() {
if (shufflePowerupCount <= 0) return;

shufflePowerupCount--;
shuffleCount.textContent = shufflePowerupCount;

// Get unmatched and unselected tiles
const unmatchedTiles = tiles.filter(tile =>
!tile.classList.contains('matched')
);

// Extract and shuffle
const tileValues = unmatchedTiles.map(tile => ({
element: tile,
numerator: tile.dataset.numerator,
denominator: tile.dataset.denominator,
value: tile.dataset.value,
difficulty: tile.dataset.difficulty
}));

shuffleArray(tileValues);

// Reinsert shuffled tiles
unmatchedTiles.forEach((tile, index) => {
const newValue = tileValues[index];
tile.innerHTML = `
<div class="fraction">
<span class="numerator">${newValue.numerator}</span>
<span class="denominator">${newValue.denominator}</span>
</div>
`;

tile.dataset.numerator = newValue.numerator;
tile.dataset.denominator = newValue.denominator;
tile.dataset.value = newValue.value;
});
}

// Event listeners
restartBtn.addEventListener('click', initGame);
playAgainBtn.addEventListener('click', initGame);
revealPowerup.addEventListener('click', revealMatch);
shufflePowerup.addEventListener('click', shuffleTiles);

// Start the game
initGame();
});
</script>
</body>
</html>
